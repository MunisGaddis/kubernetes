Kubernetes 

What is a Kubernetes Namespace?
A namespace is a way to organize cluster resources such as Pods, Services, Deployments, and other objects into separate, isolated groups.

Namespaces are used to:
Avoid naming conflicts: Resources with the same name can exist in different namespaces.
Delegate access control: Use Role-Based Access Control (RBAC) to restrict who can access what.
Separate environments: For example, use different namespaces for dev, test, and prod.
Manage resource limits: Apply quotas and limits per namespace.

üîπ Default Namespaces in a Cluster
Kubernetes comes with some built-in namespaces:

Namespace	Description
default---------The default namespace for user-created resources.
kube-system-----Used by Kubernetes system components (e.g., kube-dns).
kube-public-----Publicly accessible resources across the cluster.
kube-node-lease	-Used for node heartbeat management.

There are two ways we can create namespace :- by command or by yml file
Command to create namespace :- kubectl create namespace nginx-ns
Create with yml file
**************************************************
nano namespace.yml
kind: Namespace
apiVersion: v1
metadata:
   name: nginx-ns
***************************************************
save file 
kubectl apply -f namespace.yml
kubectl delete namespace nginx-ns
**********************************************************************************************************************************************
Pods

Kubernetes Pods are the smallest and simplest unit that you can deploy and manage in Kubernetes.
A Pod represents one or more containers (usually one) that share:

Network: Each Pod gets its own IP address. All containers in the Pod share this IP and port space.
Storage: Pods can share mounted volumes.
Lifecycle: Containers in the same Pod are managed together and are co-located.

Key Characteristics of Pods
One or More Containers:

Typically, a Pod runs a single container (1:1 mapping).
Multi-container Pods are used when containers need to work closely together (e.g., sidecar pattern).

Shared Resources:

Containers in a Pod share the same network namespace (i.e., localhost means the same across containers).
They can communicate using localhost and share storage volumes.

Ephemeral:
Pods are not self-healing. If a Pod dies, it‚Äôs replaced by a new one with a new IP (by a controller like a Deployment).

Created by Controllers:
Typically, you don‚Äôt create Pods directly.

You define them in higher-level controllers like:
Deployments
StatefulSets
DaemonSets
*********************************************************************************************************************************************
We can create Pod either via command or by writing yml file 

Create Pod via command :- 
kubectl run nginx-pod \
  --image=nginx:latest \
  --restart=Never \
  --port=80 \
  --namespace=nginx-ns

Create Pod via yml file:
********************************************************
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
  namespace: nginx-ns
  labels:
    app: nginx
spec:
  containers:
    - name: nginx
      image: nginx:latest
      ports:
        - containerPort: 80
**********************************************************
Create Pod :- kubectl apply -f pod.yml
Verify Pod :- kubectl get pods -n nginx-ns (-n means in nginx-ns namespace)
Check Pod Logs :- kubectl logs nginx-pod -n nginx-ns
Exec into Pod :- kubectl exec -it nginx-pod -n nginx-ns -- /bin/bash
************************************************************************************************************************************************

Deployment
Purpose: Manages stateless applications.

Manages: ReplicaSets (automatically).
Use Case: Ideal for web apps, APIs, frontend servers.
Pod Identity: No persistent identity. Pods are interchangeable.
Updates: Supports rolling updates and rollbacks.

Example Use Case:
Your nginx-deployment ensures that 3 replicas of the nginx container are always running and can be updated with zero downtime.

1. Nginx Deployment

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
  labels:
    app: nginx
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
*******************************************************************************************************************************        
ReplicaSet
Purpose: Maintains a stable set of replica Pods.

Manages: Pods directly.
Use Case: Rarely used on its own ‚Äî typically used by Deployments.
Pod Identity: No persistent identity. Pods are interchangeable.
Updates: No rolling update support on its own.

Example Use Case:
Your nginx-replicaset keeps 3 nginx pods running but lacks features like rolling updates. You‚Äôd have to delete and recreate to update the image. 
      
2. Nginx ReplicaSet

apiVersion: apps/v1
kind: ReplicaSet
metadata:
  name: nginx-replicaset
  labels:
    app: nginx-rs
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx-rs
  template:
    metadata:
      labels:
        app: nginx-rs
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
***********************************************************************************************************************************
 ‚úÖ 3. StatefulSet
Purpose: Manages stateful applications.

Manages: Stateful Pods with stable identity.
Use Case: Databases (like MySQL, Cassandra), queues (Kafka, RabbitMQ).
Pod Identity:
Stable hostname: nginx-statefulset-0, nginx-statefulset-1, etc.
Stable network identity.
Persistent storage via volumeClaimTemplates.

Example Use Case:
Your nginx-statefulset is useful if each nginx pod must retain its own persistent storage and identity (e.g., for caching, logs).       


3. Nginx StatefulSet

apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: nginx-statefulset
spec:
  serviceName: "nginx"
  replicas: 3
  selector:
    matchLabels:
      app: nginx-ss
  template:
    metadata:
      labels:
        app: nginx-ss
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
        volumeMounts:
        - name: www
          mountPath: /usr/share/nginx/html
  volumeClaimTemplates:
  - metadata:
      name: www
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 1Gi
          
Optional: Headless Service for StatefulSet
yaml
Copy
Edit
apiVersion: v1
kind: Service
metadata:
  name: nginx
spec:
  clusterIP: None
  selector:
    app: nginx-ss
  ports:
  - port: 80
    targetPort: 80
*********************************************************************************************************************
In Kubernetes, labels and annotations are two ways to attach metadata to Kubernetes objects (like Pods, Deployments, Services, etc.), 
but they serve slightly different purposes:

üîñ Labels
Purpose: Used to identify, organize, and select groups of objects.

Use Case: Filtering and selecting objects using label selectors (e.g., in kubectl commands, Services, ReplicaSets, Deployments, etc.)
Key characteristics:
Structured metadata.
Designed to be used in selectors.
Keys and values must conform to naming rules.

‚úÖ Example
yaml
Copy
Edit
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
  labels:
    app: myapp
    environment: production
    tier: frontend
You can use these labels to select pods:
kubectl get pods -l app=myapp
*****************************************************************************************************************************************
üìù Annotations
Purpose: Store arbitrary non-identifying metadata.

Use Case: Information that tools and libraries might use ‚Äî not for selection.
Key characteristics:
Not used in selectors.
Can store large and complex data (like JSON, config strings).
Useful for audit trails, links, checksums, etc.

‚úÖ Example

apiVersion: v1
kind: Pod
metadata:
  name: my-pod
  annotations:
    prometheus.io/scrape: "true"
    prometheus.io/port: "8080"
    description: "This pod runs the frontend of the application."
